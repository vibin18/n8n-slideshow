{"ast":null,"code":"import React,{useEffect,useRef}from'react';/**\n * Component that handles pixel transition effect between slides\n * Uses canvas to manipulate image pixels for a unique transition\n */import{jsx as _jsx}from\"react/jsx-runtime\";const PixelTransition=_ref=>{let{currentImage,previousImage,isTransitioning,onTransitionEnd}=_ref;const canvasRef=useRef(null);const animationRef=useRef(null);const pixelSize=32;// Size of each \"pixel\" block - increased for more obvious effect\nconst animationDuration=1500;// Duration in milliseconds (1.5 seconds)\nconsole.log('PixelTransition rendering with:',{currentImage,previousImage,isTransitioning});useEffect(()=>{const canvas=canvasRef.current;if(!canvas||!currentImage||!previousImage){console.log('Missing canvas or images:',{canvas,currentImage,previousImage});return;}console.log('Starting pixel transition animation');const ctx=canvas.getContext('2d');const startTime=performance.now();// Set canvas dimensions to match container\nconst container=canvas.parentElement;canvas.width=container.clientWidth;canvas.height=container.clientHeight;console.log('Canvas dimensions:',{width:canvas.width,height:canvas.height});// Create Image objects for both images\nconst imgCurrent=new Image();const imgPrevious=new Image();// Handle potential data:image URLs or regular image paths\nimgCurrent.src=currentImage;imgPrevious.src=previousImage;console.log('Image sources set');// Wait for both images to load\nlet imagesLoaded=0;const onImageLoad=()=>{imagesLoaded++;if(imagesLoaded===2){// Start animation once both images are loaded\nstartAnimation();}};imgCurrent.onload=onImageLoad;imgPrevious.onload=onImageLoad;// Animation function\nconst startAnimation=()=>{console.log('Animation starting');// Create pixel grid\nconst cols=Math.ceil(canvas.width/pixelSize);const rows=Math.ceil(canvas.height/pixelSize);console.log('Grid dimensions:',{cols,rows,pixelSize});// Create random order for pixel transitions with more interesting patterns\nconst pixels=[];for(let y=0;y<rows;y++){for(let x=0;x<cols;x++){// Add some variety to the animation by grouping pixels\nconst variant=Math.floor(Math.random()*3);// 0, 1, or 2\npixels.push({x,y,variant});}}// Create patterns rather than completely random transitions\n// Group pixels in various ways for more interesting visual effect\npixels.sort((a,b)=>{// Sort by variant first to create grouped patterns\nif(a.variant!==b.variant){return a.variant-b.variant;}// Within same variant, sort by position with some randomization\nreturn Math.random()>0.7?a.x+a.y-(b.x+b.y):Math.random()-0.5;});// Animation loop\nconst animate=timestamp=>{const elapsed=timestamp-startTime;const progress=Math.min(elapsed/animationDuration,1);// Clear canvas\nctx.clearRect(0,0,canvas.width,canvas.height);// Draw previous image as background\nctx.drawImage(imgPrevious,0,0,canvas.width,canvas.height);// Calculate how many pixels to transition based on progress\nconst pixelsToShow=Math.floor(pixels.length*progress);// Draw current image pixels with enhanced visual effect\nfor(let i=0;i<pixelsToShow;i++){const{x,y,variant}=pixels[i];const sx=x*pixelSize;const sy=y*pixelSize;// Draw a single \"pixel\" block from current image with enhanced visual effect\nctx.save();// Add different effects based on variant\nif(variant===0){// Standard replacement\nctx.drawImage(imgCurrent,sx,sy,pixelSize,pixelSize,// Source coordinates\nsx,sy,pixelSize,pixelSize// Destination coordinates\n);}else if(variant===1){// Add a small border to make the pixels more visible\nctx.drawImage(imgCurrent,sx,sy,pixelSize,pixelSize,// Source coordinates\nsx,sy,pixelSize-2,pixelSize-2// Destination coordinates (slightly smaller)\n);ctx.strokeStyle='rgba(255, 255, 255, 0.5)';ctx.strokeRect(sx,sy,pixelSize,pixelSize);}else{// Add rotation for some pixels\nctx.translate(sx+pixelSize/2,sy+pixelSize/2);ctx.rotate(Math.PI/180*(progress*90));// Rotate up to 90 degrees\nctx.drawImage(imgCurrent,0,0,pixelSize,pixelSize,// Source coordinates\n-pixelSize/2,-pixelSize/2,pixelSize,pixelSize// Destination coordinates (centered)\n);}ctx.restore();}if(progress<1){// Continue animation\nanimationRef.current=requestAnimationFrame(animate);}else{// Animation complete\nif(onTransitionEnd){onTransitionEnd();}}};// Start animation loop\nanimationRef.current=requestAnimationFrame(animate);};// Cleanup function\nreturn()=>{if(animationRef.current){cancelAnimationFrame(animationRef.current);}};},[currentImage,previousImage,isTransitioning,onTransitionEnd]);return/*#__PURE__*/_jsx(\"canvas\",{ref:canvasRef,style:{position:'absolute',top:0,left:0,width:'100%',height:'100%',display:isTransitioning?'block':'none',zIndex:5,backgroundColor:'black'// Set background to ensure visibility\n}});};export default PixelTransition;","map":{"version":3,"names":["React","useEffect","useRef","jsx","_jsx","PixelTransition","_ref","currentImage","previousImage","isTransitioning","onTransitionEnd","canvasRef","animationRef","pixelSize","animationDuration","console","log","canvas","current","ctx","getContext","startTime","performance","now","container","parentElement","width","clientWidth","height","clientHeight","imgCurrent","Image","imgPrevious","src","imagesLoaded","onImageLoad","startAnimation","onload","cols","Math","ceil","rows","pixels","y","x","variant","floor","random","push","sort","a","b","animate","timestamp","elapsed","progress","min","clearRect","drawImage","pixelsToShow","length","i","sx","sy","save","strokeStyle","strokeRect","translate","rotate","PI","restore","requestAnimationFrame","cancelAnimationFrame","ref","style","position","top","left","display","zIndex","backgroundColor"],"sources":["/Users/vibin/slideshow-master/frontend/src/components/PixelTransition.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\n\n/**\n * Component that handles pixel transition effect between slides\n * Uses canvas to manipulate image pixels for a unique transition\n */\nconst PixelTransition = ({ currentImage, previousImage, isTransitioning, onTransitionEnd }) => {\n  const canvasRef = useRef(null);\n  const animationRef = useRef(null);\n  const pixelSize = 32; // Size of each \"pixel\" block - increased for more obvious effect\n  const animationDuration = 1500; // Duration in milliseconds (1.5 seconds)\n  \n  console.log('PixelTransition rendering with:', { \n    currentImage, \n    previousImage, \n    isTransitioning \n  });\n  \n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas || !currentImage || !previousImage) {\n      console.log('Missing canvas or images:', { canvas, currentImage, previousImage });\n      return;\n    }\n    \n    console.log('Starting pixel transition animation');\n    const ctx = canvas.getContext('2d');\n    const startTime = performance.now();\n    \n    // Set canvas dimensions to match container\n    const container = canvas.parentElement;\n    canvas.width = container.clientWidth;\n    canvas.height = container.clientHeight;\n    \n    console.log('Canvas dimensions:', { width: canvas.width, height: canvas.height });\n    \n    // Create Image objects for both images\n    const imgCurrent = new Image();\n    const imgPrevious = new Image();\n    \n    // Handle potential data:image URLs or regular image paths\n    imgCurrent.src = currentImage;\n    imgPrevious.src = previousImage;\n    \n    console.log('Image sources set');\n    \n    // Wait for both images to load\n    let imagesLoaded = 0;\n    const onImageLoad = () => {\n      imagesLoaded++;\n      if (imagesLoaded === 2) {\n        // Start animation once both images are loaded\n        startAnimation();\n      }\n    };\n    \n    imgCurrent.onload = onImageLoad;\n    imgPrevious.onload = onImageLoad;\n    \n    // Animation function\n    const startAnimation = () => {\n      console.log('Animation starting');\n      // Create pixel grid\n      const cols = Math.ceil(canvas.width / pixelSize);\n      const rows = Math.ceil(canvas.height / pixelSize);\n      \n      console.log('Grid dimensions:', { cols, rows, pixelSize });\n      \n      // Create random order for pixel transitions with more interesting patterns\n      const pixels = [];\n      for (let y = 0; y < rows; y++) {\n        for (let x = 0; x < cols; x++) {\n          // Add some variety to the animation by grouping pixels\n          const variant = Math.floor(Math.random() * 3); // 0, 1, or 2\n          pixels.push({ x, y, variant });\n        }\n      }\n      \n      // Create patterns rather than completely random transitions\n      // Group pixels in various ways for more interesting visual effect\n      pixels.sort((a, b) => {\n        // Sort by variant first to create grouped patterns\n        if (a.variant !== b.variant) {\n          return a.variant - b.variant;\n        }\n        // Within same variant, sort by position with some randomization\n        return (Math.random() > 0.7) ? \n          (a.x + a.y) - (b.x + b.y) : \n          Math.random() - 0.5;\n      });\n      \n      // Animation loop\n      const animate = (timestamp) => {\n        const elapsed = timestamp - startTime;\n        const progress = Math.min(elapsed / animationDuration, 1);\n        \n        // Clear canvas\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        \n        // Draw previous image as background\n        ctx.drawImage(\n          imgPrevious, \n          0, 0, \n          canvas.width, canvas.height\n        );\n        \n        // Calculate how many pixels to transition based on progress\n        const pixelsToShow = Math.floor(pixels.length * progress);\n        \n        // Draw current image pixels with enhanced visual effect\n        for (let i = 0; i < pixelsToShow; i++) {\n          const { x, y, variant } = pixels[i];\n          const sx = x * pixelSize;\n          const sy = y * pixelSize;\n          \n          // Draw a single \"pixel\" block from current image with enhanced visual effect\n          ctx.save();\n          \n          // Add different effects based on variant\n          if (variant === 0) {\n            // Standard replacement\n            ctx.drawImage(\n              imgCurrent,\n              sx, sy, pixelSize, pixelSize, // Source coordinates\n              sx, sy, pixelSize, pixelSize  // Destination coordinates\n            );\n          } else if (variant === 1) {\n            // Add a small border to make the pixels more visible\n            ctx.drawImage(\n              imgCurrent,\n              sx, sy, pixelSize, pixelSize, // Source coordinates\n              sx, sy, pixelSize-2, pixelSize-2  // Destination coordinates (slightly smaller)\n            );\n            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';\n            ctx.strokeRect(sx, sy, pixelSize, pixelSize);\n          } else {\n            // Add rotation for some pixels\n            ctx.translate(sx + pixelSize/2, sy + pixelSize/2);\n            ctx.rotate((Math.PI / 180) * (progress * 90)); // Rotate up to 90 degrees\n            ctx.drawImage(\n              imgCurrent,\n              0, 0, pixelSize, pixelSize, // Source coordinates\n              -pixelSize/2, -pixelSize/2, pixelSize, pixelSize  // Destination coordinates (centered)\n            );\n          }\n          \n          ctx.restore();\n        }\n        \n        if (progress < 1) {\n          // Continue animation\n          animationRef.current = requestAnimationFrame(animate);\n        } else {\n          // Animation complete\n          if (onTransitionEnd) {\n            onTransitionEnd();\n          }\n        }\n      };\n      \n      // Start animation loop\n      animationRef.current = requestAnimationFrame(animate);\n    };\n    \n    // Cleanup function\n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n      }\n    };\n  }, [currentImage, previousImage, isTransitioning, onTransitionEnd]);\n  \n  return (\n    <canvas \n      ref={canvasRef} \n      style={{ \n        position: 'absolute', \n        top: 0, \n        left: 0, \n        width: '100%', \n        height: '100%', \n        display: isTransitioning ? 'block' : 'none',\n        zIndex: 5,\n        backgroundColor: 'black' // Set background to ensure visibility\n      }}\n    />\n  );\n};\n\nexport default PixelTransition;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}